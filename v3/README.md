

# Cross Contract Interactions

## Introducing the Property Registry

In this example we'll create a smart contract to act as the registry for all property listings. Think of this as a decentralized registry of available rooms, generated by the users and made available for rent. The `Property.sol` contract is going to remain the same from the last example, so we'll focus on the new `PropertyRegistry.sol` contract.

We're going to need to maintain a mapping from each property `tokenId` owned by users to some data storage in the registry (think application state). We'll use a mapping from `uint256` to a custom data type called a `struct`.

Here's the mapping:
```
mapping(uint256 => Data) public stayData;
```
Pretty straightforward and the `Data` datatype is:
```
struct Data {
  uint256 price;
  uint256 stays;
  address occupant;
}
```
We'll need to add more data fields to this struct in later examples but this should be enough to register the property with the registry.

In order to check that the user registering the property owns the ERC721 token that represents their property, we'll need to import the interface for ERC721 into this contract. This is so we can cast the address of the deployed `Property.sol` contract as an ERC721 and use it's methods.
```
import 'openzeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol';
```
We'll also need to store the address of the deployed `Property.sol` contract. We do this by passing it into the constructor of the `PropertyRegistry.sol` contract upon deployment of the registry. This will ensure we can reference the ERC721 tokens that represent properties users want to list and we can verify they own those properties.
```
//set up the property contract as minimum interface to prove ownership ERC721Basic
constructor(address _property) public {
  property = ERC721Basic(_property);
}
```
Notice we cast the address argument to the constructor as ERC721Basic. This is so we can use functions like `property.ownerOf(_tokenId)` in our modifiers for the registry and protect functions from illicit use by people who are not the owners of those properties.

Here's how we protect the `registerProperty` function.
```
modifier onlyOwner(uint256 _tokenId) {
  require(property.ownerOf(_tokenId) == msg.sender);
  _;
}
...
function registerProperty(uint256 _tokenId, uint256 _price) external onlyOwner(_tokenId) {
  stayData[_tokenId] = Data(_price, 0, address(0));
}
```
We pass the `_tokenId` argument to the modifier and call the function of the `property` contract that checks `ownerOf` since we have it casted as the `ERC721Basic.sol` interface.

That's it for now! Getting more complex in the next 2 examples!
